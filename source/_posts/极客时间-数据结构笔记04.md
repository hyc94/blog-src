---
title: 数据结构笔记04-复杂度分析（下）
date: 2018-11-29 22:00:17
tags: 数据结构
categories: 基础
---

* 最好、最好情况时间复杂度
* 平均情况时间复杂度
* 均摊时间复杂度

------

<!-- more -->

## 样例代码：

```
//n 表示数组array的长度
int find(int[] array, int n, int x) {
    int i = 0;
    int pos = -1;
    for (; i < n; ++i) {
        if (array[i] == x) {
            pos = i;
            break;
        }
    }
    return pos;
}
```



## 最好、最坏情况时间复杂度

为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。当x正好是数组的第一个元素，这个$O(1)$就是最好情况时间复杂度。

最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。当x正好是数组的最后一个元素，这个$O(n)$就是最坏情况时间复杂度。

## 平均情况时间复杂度

要查找的变量x在数组的位置有n+1中情况：在数组的0~n-1位置中和不在数组中。我们把每种情况下需要遍历的元素个数累加求和，再除以n+1，得到需要遍历的平均值：
$$
\frac{1+2+3+...+n+n}{n+1}=\frac{n(n+3)}{2(n+1)}
$$
时间复杂度的大$O$标记法中，可以省略掉系数、低阶、常量，所以平均时间复杂度就是$O(n)$。

但是其实上面的计算过程稍微有点问题，因为n+1种情况出现的概率不同。如果我们把每种情况发生的概率考虑进去，假设在数组中和不在数组的概率都为1/2，要查找的数据出现在0~n-1的概率是一样的，为1/n，计算公式就变成了这样：
$$
1\times\frac{1}{2n} + 2\times\frac{1}{2n} + 3\times\frac{1}{2n} +... + n\times\frac{1}{2n} + n\times\frac{1}{2}=\frac{3n+1}{4}
$$
这个值就是概率中的**加权平均值**，也叫作**期望值**，所以平均情况时间复杂度的全称应该是**加权平均时间复杂度**或者**期望值时间复杂度**。引入概率之后，用大$O$表示法来表示，这段代码的平均情况时间复杂度仍然是$O(n)$。

大部分情况下，我们使用一个复杂度就可以满足需求了，只有同一块代码在不同情况下，时间复杂度有量级的差距，我们才会用这三种复杂度表示法来区分。